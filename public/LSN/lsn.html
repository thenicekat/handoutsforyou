<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Lab Sheets and Notes</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-interactiveBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="7b554b95-1577-449f-a210-013fdf50ecf5" class="page sans"><header><h1 class="page-title">Lab Sheets and Notes</h1><p class="page-description"></p></header><div class="page-body"><nav id="f94b411f-6b96-4210-824c-27905c0bb59c" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#60f66bab-fe2e-425b-875c-67a7207715e1">Mathematical</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b03ffc44-c9ee-41ed-97c3-3bf99f95ed38">Non Repeating Numbers using BIT Manipulation</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#10f62ab3-4861-4dad-bbc5-a38fe114ad40">Time Complexities</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#70340fb4-d755-49a9-9c76-890ec6a409b4"><strong>Common time complexities</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#34ba8107-0c9e-4487-be70-9352198732af"><strong>Examples of each common time complexity</strong></a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#f4c44238-c29d-485e-b140-c266b0994bab">Arrays</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#9379f315-2991-4189-b0f1-8e716baaa6fb">Linked Lists</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#73ce2d59-09a3-49e0-9750-39f5fa006f5d">Doubly Linked Lists</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#31dd8ba1-66e6-4171-8d4f-fab3eeeb2628">Binary Search (Sorted, Minimum, Maximum, Minimum of Maximum, Maximum of Minimum)</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#82399542-e742-4746-9a40-5182918d9a5e">Strings</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#80b641a9-c90c-4b24-9b8e-0d527b58ed77">Sorting (Two Pointers)</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#7a55efe4-ef05-4656-bb7a-94a83b459e78">Recursion</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#875e8014-4809-4892-aec8-f585f90a819f">Sliding Window(Longest Substring) + Prefix Sum</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#1a7f5795-ddd4-4523-b848-7b380e2df580">Stacks and Queues</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#968d16aa-acc0-4f70-8749-a186c16dc3ec">Tree: Bipartite Graph</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#422d420c-5c5c-4a5f-8ad8-ffc4de88ef93">Heap</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#860841e7-0a1a-4a9a-a837-e1c915ff19d2">Maps and Sets</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a5daf252-3a9b-4565-afba-890fc9fba00e">Multiset</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#dfad1d4c-6cd6-4ecd-9095-bf0d84d46de3">Divide and Conquer + Subarray Types</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#6576cc29-64ff-476e-bd89-c990aaf63f94">Greedy Algorithm</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#22b08bc7-bbb1-4df4-9d49-db445319d5c3">Dynamic Programming</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#df1cf2ac-c22b-4460-b555-f6bde43b6a3f">Converting Memoization to Tabulation</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#fb9cf0a0-22ac-4034-96b4-69e5cfb40711">Tries</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#c93f1865-b14e-42b4-ab4d-a9550127a21b">Graphs BFS + DFS</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c83a2950-b220-4fab-8bcd-141fd495e7ea">Bridges in Graphs</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e42fd81c-f33a-4f9a-af9e-c72edb3cafb1">Kahn’s Algorithm: BFS in topo sorting</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d4be0dfe-ba9a-4c19-b4fd-5ac9df75bc8d">Dijkstra’s Algorithm → E Log V</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0fcd1094-a4f8-472a-87ce-5c8ad7b2d1aa">Bellman Ford O(n*m)</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e79e60ee-2010-47d3-9eae-4f5d2d6a3e49">Floyd Warshall - Multiple Sources and Destinations</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#09145549-c60a-4ebb-b106-848609ea569d">Disjoint Set Data Structure - O(4 Alpha)</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#386ae5c8-e434-4fa5-b36b-6f01d59cc2b8">Minimum Spanning Tree</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f8fabb84-510d-46ac-b719-0e1ec0e07698">Prims (Uses BFS)</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e65d207e-1f62-42c1-874b-6d2700edb5b1">Kruskal’s (Uses DSU)</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#3e641b89-7272-4f74-bddb-9f73ecf890e0">Fenwick Tree aka Binary Indexed Tree</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#761625ec-261a-4748-8d3d-5f7319761eba">Segment Tree</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#ca95381b-b575-4cec-81a0-5a861d60d938">Minimum Exclusion Number</a></div></nav><h1 id="60f66bab-fe2e-425b-875c-67a7207715e1" class="">Mathematical</h1><h3 id="b03ffc44-c9ee-41ed-97c3-3bf99f95ed38" class="">Non Repeating Numbers using BIT Manipulation</h3><ul id="261721bf-2bce-4452-945d-42e9e651f449" class="bulleted-list"><li style="list-style-type:disc">So basically in this we find <span style="border-bottom:0.05em solid">last set bit</span> and compare with all numbers, and we xor it, so say we have a a b b c belonging to the set where last set bit is 1 → we do a^a^b^b^c</li></ul><ul id="f236ece6-a92e-4d84-bda1-0e31d65f43f9" class="bulleted-list"><li style="list-style-type:disc">And remaining numbers get XORed separately<pre id="27ee228d-0258-414e-96eb-01eb5a099693" class="code"><code>#include &lt;bits/stdc++.h&gt;
vector&lt;int&gt; findNonRepeating(vector&lt;int&gt; a) {
	int xornum = a[0];
	for(int i=1; i&lt;a.size(); i++) xornum ^= a[i];

	int lastBit = xornum &amp; ~(xornum - 1);

	int x = 0;
	int y = 0;

	for(int i=0; i&lt;a.size(); i++){
		if(a[i] &amp; lastBit){
			x ^= a[i];
		}else{
			y ^= a[i];
		}
	}
	return { x, y };
}</code></pre></li></ul><h1 id="10f62ab3-4861-4dad-bbc5-a38fe114ad40" class="">Time Complexities</h1><h3 id="70340fb4-d755-49a9-9c76-890ec6a409b4" class=""><strong>Common time complexities</strong></h3><p id="aa18dad6-6bb9-4266-880a-29836b13bd2c" class="">Let <em>n</em> be the main variable in the problem.</p><ul id="a2d9f067-3fc6-4698-8975-6f90b103324b" class="bulleted-list"><li style="list-style-type:disc">If <em>n</em> ≤ 12, the time complexity can be O(n!).</li></ul><ul id="833b53b4-3a36-40e3-b32e-77aca4a417d2" class="bulleted-list"><li style="list-style-type:disc">If <em>n</em> ≤ 25, the time complexity can be O(2^n).</li></ul><ul id="4ff9a4db-e415-46dd-a033-e1c958bafa91" class="bulleted-list"><li style="list-style-type:disc">If <em>n</em> ≤ 100, the time complexity can be O(n^4).</li></ul><ul id="7e5fdb7b-534b-41ec-83a0-5fabdd1af39b" class="bulleted-list"><li style="list-style-type:disc">If <em>n</em> ≤ 500, the time complexity can be O(n^3).</li></ul><ul id="c99f7208-0e9a-4531-9012-c80860c3e2be" class="bulleted-list"><li style="list-style-type:disc">If <em>n</em> ≤ 10^4, the time complexity can be O(n^2).</li></ul><ul id="556ffb80-a11e-49f5-84b0-af645ee54571" class="bulleted-list"><li style="list-style-type:disc">If <em>n</em> ≤ 10^6, the time complexity can be O(n log n).</li></ul><ul id="08e9ac66-4a32-4c00-8bf5-54ddfede4ff3" class="bulleted-list"><li style="list-style-type:disc">If <em>n</em> ≤ 10^8, the time complexity can be O(n).</li></ul><ul id="0624b1b3-1360-43bd-b46d-ca8d3fddd41a" class="bulleted-list"><li style="list-style-type:disc">If <em>n</em> &gt; 10^8, the time complexity can be O(log n) or O(1).</li></ul><h3 id="34ba8107-0c9e-4487-be70-9352198732af" class=""><strong>Examples of each common time complexity</strong></h3><ul id="c4ebcf43-d51b-4372-8c46-831d33a1212b" class="bulleted-list"><li style="list-style-type:disc">O(n!) [Factorial time]: Permutations of 1...<em>n</em></li></ul><ul id="f7411c43-156a-4651-a3e3-44697a6527e5" class="bulleted-list"><li style="list-style-type:disc">O(2^n) [Exponential time]: Exhaust all subsets of an array of size <em>n</em></li></ul><ul id="7479ef5f-efb7-4034-800f-29330199102a" class="bulleted-list"><li style="list-style-type:disc">O(n^3) [Cubic time]: Exhaust all triangles with side length less than <em>n</em></li></ul><ul id="673897fc-afae-436e-ad10-ebad460bd4a3" class="bulleted-list"><li style="list-style-type:disc">O(n^2) [Quadratic time]: Slow comparison-based sorting (e.g. Bubble Sort, Insertion Sort, Selection Sort)</li></ul><ul id="962a1daa-86a9-4b88-9f88-f73a523a895d" class="bulleted-list"><li style="list-style-type:disc">O(n log n) [Linear-log time]: Fast comparison-based sorting (e.g. Merge Sort)</li></ul><ul id="8afe85d5-784a-44d8-993a-1b58499d05bd" class="bulleted-list"><li style="list-style-type:disc">O(n) [Linear time]: Linear Search (Finding maximum/minimum element in a 1D array), Counting Sort</li></ul><ul id="78bc508d-cb37-4101-b7b6-b481298d5496" class="bulleted-list"><li style="list-style-type:disc">O(log n) [Logarithmic time]: Binary Search, finding GCD (Greatest Common Divisor) using Euclidean Algorithm</li></ul><ul id="f6ec3129-45de-4cc9-ace3-41676286926c" class="bulleted-list"><li style="list-style-type:disc">O(1) [Constant time]: Calculation (e.g. Solving linear equations in one unknown)</li></ul><h1 id="f4c44238-c29d-485e-b140-c266b0994bab" class="">Arrays</h1><ul id="f5710deb-2bd3-4ee4-b83c-11c4a7018d73" class="bulleted-list"><li style="list-style-type:disc">For minimum swaps you can probably think of sliding window also </li></ul><ul id="3ac4c7a4-a2ca-4fac-aadc-4880b97d83d1" class="bulleted-list"><li style="list-style-type:disc">For maximum product subarray, we need to maintain 2 products, from left and from right, and take maximum<ul id="26897119-b154-473e-af85-5ac37893c230" class="bulleted-list"><li style="list-style-type:circle">Like we observe that either all numbers should be considered or one side and from there we can get this logic</li></ul><ul id="36686ebe-60fa-4cd8-bede-8adf1ec8ca78" class="bulleted-list"><li style="list-style-type:circle">We get O(n) approach</li></ul></li></ul><h1 id="9379f315-2991-4189-b0f1-8e716baaa6fb" class="">Linked Lists</h1><ul id="70221063-c5d7-4bd9-a884-60902cc09fd3" class="bulleted-list"><li style="list-style-type:disc">We have the fast-slow method in Linked Lists where you make one pointer move twice every time the other pointer moves once. This leads to the slower one stopping at the middle of the linked list in O(n)</li></ul><ul id="b12ba4f1-9daa-4ff5-bb12-db4d24a8bed3" class="bulleted-list"><li style="list-style-type:disc">For merging two sorted linked lists, you can use recursion and based on which one is smaller, you can recursively call the same function<pre id="bedf30d0-5aa6-44b0-9fcb-390453eea4f5" class="code"><code>Node *temp = NULL;

if (head1-&gt;data &lt; head2-&gt;data)
{
    temp = head1;
    temp-&gt;next = mergeLists(head1-&gt;next, head2);
}
else
{
    temp = head2;
    temp-&gt;next =  mergeLists(head1, head2-&gt;next);
}</code></pre></li></ul><ul id="34ec9222-79a2-485d-b304-bb7a835e5063" class="bulleted-list"><li style="list-style-type:disc">To check palindrome, you can reverse list and compare in O(n)</li></ul><h1 id="73ce2d59-09a3-49e0-9750-39f5fa006f5d" class="">Doubly Linked Lists</h1><ul id="91b74a84-4e54-440c-be0d-77511624dbd0" class="bulleted-list"><li style="list-style-type:disc">Doubly Linked Lists - Implementation pain</li></ul><ul id="9c7ca6ff-59f8-4efd-945d-fcccae79d0ad" class="bulleted-list"><li style="list-style-type:disc">Used in LRU Cache and LFU Cache</li></ul><h1 id="31dd8ba1-66e6-4171-8d4f-fab3eeeb2628" class="">Binary Search (Sorted, Minimum, Maximum, Minimum of Maximum, Maximum of Minimum)</h1><ul id="5350ee9c-3861-4ee2-a838-370ccb1172c6" class="bulleted-list"><li style="list-style-type:disc">You can use Binary Search to get first and last occurrences of a number in a sorted array<ul id="3adf688f-9e85-4156-bccd-575878dd70c8" class="bulleted-list"><li style="list-style-type:circle">The idea is like we use normal Binary Search but if the element is found, then we go leftwards for first occurrence and right wards for last occurrence</li></ul></li></ul><ul id="f9268fab-3853-4508-9470-2fcbb28abd71" class="bulleted-list"><li style="list-style-type:disc">We can use binary search in rotated arrays also by getting the fact that one side will be sorted</li></ul><ul id="b90ff9d8-09db-444c-8750-78a7ad9775df" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.youtube.com/watch?v=on2hvxBXJH4">DP 43. Longest Increasing Subsequence | Binary Search | Intuition - YouTube</a></li></ul><ul id="a3ecac2b-95d2-4a14-9a8e-8f2432c0cf3b" class="bulleted-list"><li style="list-style-type:disc">LIS</li></ul><pre id="83531acf-ea96-478f-a0cc-45c315baf48d" class="code code-wrap"><code>		vector&lt;int&gt; store;
    for(int i=0; i&lt;nums.size(); i++){
        if(lower_bound(store.begin(), store.end(), nums[i]) != store.end()){
            store[lower_bound(store.begin(), store.end(), nums[i]) - store.begin()] = nums[i];
        }else{
            store.push_back(nums[i]);
        }
    }
    return store.size();</code></pre><ul id="63b754b5-326c-4160-8cd0-391a5883a820" class="bulleted-list"><li style="list-style-type:disc">LIS also we can use Binary search, basically upperbound<figure id="f6a645f3-1c37-4b84-9c18-00bca616bbc3" class="image"><a href="Lab%20Sheets%20and%20Notes%207b554b951577449fa210013fdf50ecf5/Untitled.png"><img style="width:1322px" src="Lab%20Sheets%20and%20Notes%207b554b951577449fa210013fdf50ecf5/Untitled.png"/></a></figure></li></ul><ul id="04eb8f00-02b0-4c4f-aed7-dca64e1637b6" class="bulleted-list"><li style="list-style-type:disc">LIS also used in Russian doll question where we sort based on height in increasing order and width in decreasing order and then use LIS on height</li></ul><ul id="ac228882-494e-47b2-8387-428cebf9d94d" class="bulleted-list"><li style="list-style-type:disc">We can also use binary search to find next permutation given which permutation you need but this is sort of tricky<ul id="060c6847-8408-4586-8077-3e1042d6c228" class="bulleted-list"><li style="list-style-type:circle">If we have digits 1,2,3,4 </li></ul><ul id="a857f0b7-15e7-470c-b93b-e3c8437f626b" class="bulleted-list"><li style="list-style-type:circle">With 4 we get 6</li></ul><ul id="48e152b4-f15d-4190-bc7e-c327adc04bf8" class="bulleted-list"><li style="list-style-type:circle">With 3 we get 6</li></ul><ul id="22bcd6a0-e5e6-406d-a391-bc28e3a825ee" class="bulleted-list"><li style="list-style-type:circle">and so on we can keep going</li></ul></li></ul><ul id="751ca5f8-adc6-4e38-bcd8-9f2d4decd305" class="bulleted-list"><li style="list-style-type:disc">Book allocation Problem (Binary Search) <a href="https://www.youtube.com/watch?v=gYmWHvRHu-s">Allocate Minimum Number of Pages | Binary Search - YouTube</a>. We allocate contagious pages using a check function and binary search<pre id="90e98c38-4cf8-4dd6-aba6-ba8735d1902d" class="code code-wrap"><code>int checkIfPossible(int books[], int booksLength, int noOfPeople, int barrier)
{
    cout &lt;&lt; &quot;Barrier: &quot; &lt;&lt; barrier &lt;&lt; endl;
    int noOfStudents = 1;
    int currStudent = 0;

    for (int i = 0; i &lt; booksLength; i++)
    {
        if (currStudent + books[i] &gt; barrier)
        {
            noOfStudents++;
            currStudent = books[i];
        }
        else
        {
            currStudent += books[i];
        }
    }
    return (noOfStudents &lt;= noOfPeople);
}</code></pre></li></ul><ul id="52af229a-aa22-4a33-a0d0-2754a0583211" class="bulleted-list"><li style="list-style-type:disc">Ternary Search used in cases which involves finding min points <pre id="9ed91e3c-f668-459b-958b-a738042c6975" class="code"><code>double distance(int a, int b, int c, vector&lt;vector&lt;int&gt;&gt; &amp;points, double x){
	double y = (-c-(a*x))/b;
	double ans = 0;
	for(auto point: points){
		ans += sqrt(((x - point[0])*(x - point[0])) + ((y - point[1])*(y - point[1])));
	}
	return ans;
}

double optimumDistance(int a, int b, int c, vector&lt;vector&lt;int&gt;&gt; &amp;points, int n){
	double end = 100, start = -100;

	while(start &lt; end){
		double m1=start +(end-start)/3;
		double m2=end -(end-start)/3;

		double f1=distance(a,b,c,points, m1);
		double f2=distance(a,b,c,points, m2);

		if(f1&gt;f2) start=m1;
		else if(f1&lt;f2) end=m2;
		else{
			start=m1;
			end=m2;
		}
	}

	double x=(start+end)/2;
	return distance(a,b,c,points,x);
}</code></pre></li></ul><h1 id="82399542-e742-4746-9a40-5182918d9a5e" class="">Strings</h1><ul id="9daadddc-d409-438f-b62e-add635fb7094" class="bulleted-list"><li style="list-style-type:disc">Generate next string lexographically<pre id="83b269ce-b759-4210-9703-20b63b147314" class="code code-wrap"><code>int i = x.length() - 1;
while(i &gt;= 0){
    if(x[i] == limit){
        i--;
    }else{
        x[i] = x[i] + 1;
        for(int m = i+1; m &lt; x.length(); m++) x[m] = &#x27;a&#x27;;
        cout &lt;&lt; x &lt;&lt; endl;
        break;
    }
}</code></pre></li></ul><h1 id="80b641a9-c90c-4b24-9b8e-0d527b58ed77" class="">Sorting (Two Pointers)</h1><ul id="144a3e57-aef8-4863-9448-ca1ae8570a3f" class="bulleted-list"><li style="list-style-type:disc">In C++, use comparator functions with the built in sort function</li></ul><ul id="55c618d9-05cb-47e6-8b56-ed2123a5912d" class="bulleted-list"><li style="list-style-type:disc">Sieve of Eratosthenes is a nice way to get prime numbers between a range or something like that</li></ul><ul id="4f3793da-fdc8-4ae4-b3fb-fc45259228bd" class="bulleted-list"><li style="list-style-type:disc">GCD or just use <code>__gcd()</code><pre id="0092aa85-7b7a-47cd-994d-17e35f12ab05" class="code"><code>int gcd(int a, int b)
{
    if(a == 0) return 0;
    if(b == 0) return a;
    return gcd(b, a%b);
}</code></pre></li></ul><ul id="8acd5818-c57b-4f2e-b9c4-b59ce0981383" class="bulleted-list"><li style="list-style-type:disc">Sorted rotated array<pre id="f4984586-d5e2-416b-b27c-d234c2516164" class="code"><code>int search(int* arr, int n, int key) {
    int left = 0;
    int right = n-1;
		// so here 
    while(left &lt;= right){
        int mid = (left + right)/2;
        if (arr[mid] == key) {
          return mid;
        }

        if(arr[left] &lt;= arr[mid]){
            if(arr[left] &lt;= key &amp;&amp; key &lt;= arr[mid]){
                right = mid - 1;
            }else{
                left = mid + 1;
            }
        }

        else{
            if(arr[mid] &lt;= key &amp;&amp; key &lt;= arr[right]){
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }        
    }

    return -1;
}</code></pre></li></ul><ul id="cf680dba-2bcb-41cf-a8d8-010dbf60dcf3" class="bulleted-list"><li style="list-style-type:disc"><a href="https://medium.com/swlh/binary-search-find-upper-and-lower-bound-3f07867d81fb">Binary Search — Find Upper and Lower Bound | by OnePunch | The Startup | Medium</a></li></ul><h1 id="7a55efe4-ef05-4656-bb7a-94a83b459e78" class="">Recursion</h1><ul id="6724dd25-91b5-477b-b117-73371d9f6399" class="bulleted-list"><li style="list-style-type:disc">Palindrome Partitioning: Recurse such that next substring is palindrome 🙂</li></ul><ul id="9ffa977f-fbcd-43bb-9a4b-bf606c8b19f0" class="bulleted-list"><li style="list-style-type:disc">Parenthesis Counter: if open &lt; max add open and if close &lt; open add close</li></ul><ul id="3e4d1b3e-45e5-4490-a234-6ce09a532c09" class="bulleted-list"><li style="list-style-type:disc">Back tracking is where you add number, get it back to the same state and continue doing it with a different addition<pre id="6335f3ad-67e1-488d-a2ec-b4b33ca98f79" class="code"><code>void recursiveMinimumUnfairness(int *buckets, int *answer, int noOfPeople, int index, int* finalAnswer, int currmax)
{
    // If we passed through all the chicken buckets, then we return the minimum maximum
    if (index == -1)
    {
        (*finalAnswer) = min((*finalAnswer), currmax);
        return;
    }

    // For each person, we add chicken, recurse and then remove that chicken and check again
    for (int i = 0; i &lt; noOfPeople; i++)
    {
        answer[i] += buckets[index];
        recursiveMinimumUnfairness(buckets, answer, noOfPeople, index - 1, finalAnswer, max(answer[i], currmax));
        answer[i] -= buckets[index];
    }

    return;
}</code></pre></li></ul><h1 id="875e8014-4809-4892-aec8-f585f90a819f" class="">Sliding Window(Longest Substring) + Prefix Sum</h1><ul id="7a70721f-90f9-4c9b-82a4-b9b151183431" class="bulleted-list"><li style="list-style-type:disc">Sliding Window<pre id="fc078231-cc0c-41bd-b605-65617d950f56" class="code"><code>while(end &lt; num &amp;&amp; start &lt;= end){
    printf(&quot;%lld %lld %lld %lld\n&quot;, start, end, noOfZeroes, end - start + 1);
    if(noOfZeroes == noOfZ){
        answer = max(answer, end - start + 1);
    }
    
    if(noOfZeroes &lt;= noOfZ){
        end++;
        if(end == num) break;
        if(input[end] == 0) noOfZeroes++;
    }else{
        if(input[start] == 0) noOfZeroes--;
        start++;
    }
}</code></pre></li></ul><ul id="e0be0361-3f7e-4c7e-8d68-fffc6a50b563" class="bulleted-list"><li style="list-style-type:disc">Sum has to be divisible by the number given. So basically in the prefix sum, say we have b and a  if b%6 = n and a%6 = n then (b-a)%6 = 0. Which gives us a sub array whose sum is a multiple of 6 So we find reminders for all the elements in the prefix sum. And if 2 numbers have same reminders, we get 1 set so we use nC2 formula</li></ul><ul id="0b071042-9fdb-46cc-a1fc-1dc18f3f3e62" class="bulleted-list"><li style="list-style-type:disc">Reservoir Sampling<pre id="cb263a94-1635-48c0-a8b9-85a066dfcb2f" class="code"><code>https://www.geeksforgeeks.org/reservoir-sampling/
https://www.youtube.com/watch?v=A1iwzSew5QY</code></pre></li></ul><h1 id="1a7f5795-ddd4-4523-b848-7b380e2df580" class="">Stacks and Queues</h1><ul id="bc93c8f7-a95c-4cc0-86bd-6ccc54c727e0" class="bulleted-list"><li style="list-style-type:disc">Using stacks, you can get the the nearest smaller/greater number</li></ul><ul id="f0cde386-d11a-4233-bfa5-b458f34653f2" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.youtube.com/watch?v=_RtghJnM1Qo">https://www.youtube.com/watch?v=_RtghJnM1Qo</a></li></ul><ul id="bea88acb-e756-4e52-b53f-8e865bf1293d" class="bulleted-list"><li style="list-style-type:disc">Using stack, you can find the lowest number before it and the lowest number after it, using these two, you can find area as (next - previous) * height</li></ul><ul id="abd51664-644e-401d-a523-f44d1fc496ac" class="bulleted-list"><li style="list-style-type:disc">Use queue for adding digits to number </li></ul><ul id="4593ba94-9e2e-4901-a290-314bc20fed34" class="bulleted-list"><li style="list-style-type:disc">Minimum cost to make string valid<ul id="916bbc6e-6bc0-4a75-b5ab-1ee4e2834071" class="bulleted-list"><li style="list-style-type:circle">Formula ⇒ (opening + 1)/2 + (closing + 1)/2</li></ul><ul id="a7953aa4-84ab-49be-9466-20d132d722a7" class="bulleted-list"><li style="list-style-type:circle">Logic being half of openings will cover other half of openings</li></ul></li></ul><ul id="22195eb8-553b-43d7-9c64-cb4dfe12132a" class="bulleted-list"><li style="list-style-type:disc"><a href="https://leetcode.com/problems/sliding-window-maximum/solutions/871317/clear-thinking-process-with-picture-brute-force-to-mono-deque-python-java-javascript/">Clear thinking process with PICTURE, brute force to mono deque, python/java/javascript - Sliding Window Maximum - LeetCode</a></li></ul><ul id="49d9ad00-4fa2-4dac-8ee0-54d28fc54ca4" class="bulleted-list"><li style="list-style-type:disc"><a href="https://leetcode.com/problems/sliding-window-maximum/solutions/65898/clean-c-o-n-solution-using-a-deque/?orderBy=most_votes">Clean C++ O(n) solution using a deque - Sliding Window Maximum - LeetCode</a><pre id="4401f214-b616-4fd9-bf4d-d0c1339572b1" class="code code-wrap"><code>class Solution {
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {
        deque&lt;int&gt; dq;
        vector&lt;int&gt; ans;
        for (int i=0; i&lt;nums.size(); i++) {
            if (!dq.empty() &amp;&amp; dq.front() == i-k) dq.pop_front();
            while (!dq.empty() &amp;&amp; nums[dq.back()] &lt; nums[i])
                dq.pop_back();
            dq.push_back(i);
            if (i&gt;=k-1) ans.push_back(nums[dq.front()]);
        }
        return ans;
    }
};</code></pre></li></ul><ul id="94a1d383-b63e-4e3b-b0f2-4867c235a814" class="bulleted-list"><li style="list-style-type:disc">How to solve stack questions without multiple passes for next and previous smaller element<ul id="3b7fca75-42bd-4f7c-ba42-352f9845bcc4" class="bulleted-list"><li style="list-style-type:circle">In the question where you are given a lot of rectangles, you can go from top to bottom and do nicely stack per floor and you get max area of rectangles</li></ul><pre id="b7336e7e-e1d8-4c55-b38e-033e1cdd9eff" class="code"><code>int findMax(vector&lt;int&gt; dp){
    int maxArea = 0;
    stack&lt;int&gt; s;
    int n = dp.size();

    for(int i=0; i&lt;=n; i++){
        while(!s.empty() &amp;&amp; (i == n || dp[s.top()] &gt;= dp[i])){
            int h = dp[s.top()];
            s.pop();

            int w;
            if(s.empty()) w = i;
            else w = i - st.top() - 1;

            maxArea = max(maxArea, h*w);
        }
        st.push(i);
    }
    return maxArea;
}</code></pre></li></ul><h1 id="968d16aa-acc0-4f70-8749-a186c16dc3ec" class="">Tree: Bipartite Graph</h1><ul id="ba0d0514-8d98-437b-90b1-550fb8d8d4cc" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.geeksforgeeks.org/check-if-a-given-array-can-represent-preorder-traversal-of-binary-search-tree/">Check if a given array can represent Preorder Traversal of Binary Search Tree - GeeksforGeeks</a> → Use stack</li></ul><ul id="7358b2d7-cdf8-434e-a40a-b76849f7fcf2" class="bulleted-list"><li style="list-style-type:disc">Using in order and preorder we can make tree by recursively traveling</li></ul><ul id="7a522e2b-2ff0-4591-85c2-4a8280231ec6" class="bulleted-list"><li style="list-style-type:disc">DFS can be done using recursion and we can use DFS to find out number of islands</li></ul><ul id="8a8cd931-4b96-4dd4-88ba-84b2d5d8bb8c" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid">BFS</span> generally uses <span style="border-bottom:0.05em solid">queue</span>. Word ladder question is BFS where you start with a word iterate through all next possible words<pre id="83b6ff79-2a87-4d8e-8478-d8bea673f5a4" class="code"><code>#include &lt;bits/stdc++.h&gt;
int wordLadder(string begin, string end, vector&lt;string&gt; &amp;dict) 
{
	unordered_set&lt;string&gt; words;
	for(auto x: dict){
		words.insert(x);
	}
	queue&lt;pair&lt;string, int&gt;&gt; q;
	q.push({ begin, 1 });

	if(words.find(end) == words.end()) return -1;

	while(!q.empty()){
		string curr = q.front().first;
		int level = q.front().second;
		q.pop();

		string original = curr;
		
		for(int i=0; i&lt;curr.length(); i++){
			char orig = curr[i];
			for(int m=0; m&lt;26; m++){
				curr[i] = &#x27;a&#x27; + m;
				if(curr == end){
					return level + 1;
				}
				if(words.find(curr) != words.end() &amp;&amp; curr[i] != orig){
					words.erase(curr);
					q.push({ curr, level + 1 });
				}
			}
			curr[i] = orig;
		}
	}

	return -1;

}</code></pre></li></ul><ul id="46cbaf95-3c27-4d81-b5fa-4b6768598283" class="bulleted-list"><li style="list-style-type:disc">In order Traversal always gives you a sorted list :)</li></ul><ul id="b56183d6-387e-46cd-8834-b4f5e091e6fa" class="bulleted-list"><li style="list-style-type:disc">Total number of binary trees and binary search trees → <a href="https://www.geeksforgeeks.org/total-number-of-possible-binary-search-trees-with-n-keys/">Total number of possible Binary Search Trees and Binary Trees with n keys - GeeksforGeeks</a></li></ul><ul id="5a8a5ed6-d8a6-4620-9d44-e7be631a678d" class="bulleted-list"><li style="list-style-type:disc">Also to get kth element in 2 sorted array we can use the cuts wala logic, it&#x27;s simple only but hard to understand. Say we want 5th element: the simple logic is that all numbers to left of both cuts should be smaller and cuts are made like 3 on left in 1st array then 2 will be there in second array</li></ul><ul id="1bbc152b-9d2a-464c-afdf-6247b49c5b70" class="bulleted-list"><li style="list-style-type:disc">We can check <span style="border-bottom:0.05em solid">symmetricity of trees</span> by using recursively calling on (a→left, b→right) and (a→right, b→left)</li></ul><ul id="fd7678d4-6c9a-4d8e-a17e-429e51624208" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid">Boundary Traversal</span> = Left Boundary + Leaves (DFS and not BFS) + Right Boundary<ul id="b2c6df23-afcc-4ddf-8b37-0fbf09950c78" class="bulleted-list"><li style="list-style-type:circle">Note: Left Boundary not same as left view. For left view and right view we use BFS</li></ul><ul id="08304b82-9f3c-4ea4-90b8-6efaa8e5983d" class="bulleted-list"><li style="list-style-type:circle">For boundary we recursively call on left else right for left and on right else left fir right</li></ul></li></ul><ul id="524ef790-38b9-42bb-ba11-d075e5e0a13e" class="bulleted-list"><li style="list-style-type:disc">For constructing tree from preorder, we can just go from left to right recursively cause preorder mein nodes are left to right, so construct all left nodes, then all right nodes</li></ul><ul id="4e579203-073b-4ba6-9414-5875b1a1aa24" class="bulleted-list"><li style="list-style-type:disc">If we need to find <span style="border-bottom:0.05em solid">max number of non adjacent nodes</span> in a tree, you will need to use pick/nonpick wala dp method<pre id="02c0ab34-abe6-4cab-baae-d98a4ac609be" class="code"><code>	int pick = 1;
  if(root-&gt;left) pick += traverseTree(root-&gt;left-&gt;left, dp);
  if(root-&gt;left) pick += traverseTree(root-&gt;left-&gt;right, dp);
  if(root-&gt;right) pick += traverseTree(root-&gt;right-&gt;left, dp);
  if(root-&gt;right) pick += traverseTree(root-&gt;right-&gt;right, dp);

  int notPick = traverseTree(root-&gt;left, dp) + traverseTree(root-&gt;right, dp);</code></pre></li></ul><ul id="1dcecc8e-9d7d-4ede-bc17-e59e637fa083" class="bulleted-list"><li style="list-style-type:disc">Equal sum partition tree, take sum of total tree then check for tree where sum becomes half</li></ul><ul id="381cfaad-632f-4806-a8e5-fcfccbda0048" class="bulleted-list"><li style="list-style-type:disc">I think for the duplicate subtrees, we just map all of them if there’s 2 with same number then they become oh we can’t do using sum but we can use strings and store using the following example<pre id="20ada13f-b54e-4a6a-b1c9-e4e0a109baad" class="code"><code>string checkTree(BinaryTreeNode&lt;char&gt; * root, map&lt;string, int&gt; &amp;mp){
    if(root == nullptr) return &quot;&quot;;
    string left = checkTree(root-&gt;left, mp);
    string right = checkTree(root-&gt;right, mp);

    string curr = &quot;(&quot; + left + &quot;&gt;&quot; + root-&gt;data + &quot;&gt;&quot; + right + &quot;)&quot;;
    if(mp.find(curr) != mp.end() &amp;&amp; curr.length() &gt; 5){
        ans = true;
    }
    mp[curr]++;
    return curr;
}</code></pre></li></ul><h1 id="422d420c-5c5c-4a5f-8ad8-ffc4de88ef93" class="">Heap</h1><ul id="60c8dc15-0b9c-4779-9e80-20f9b68aa6f1" class="bulleted-list"><li style="list-style-type:disc">We can keep track of insertions and deletions using priority queue of the format (number, (array index, number index)) </li></ul><ul id="7be7a59c-01c8-40bb-973b-c1cbf959f35d" class="bulleted-list"><li style="list-style-type:disc">If there’s a case where we need to get positive sum all the time, we can use priority queue and remove most negative numbers,  also works when you are playing game greedily sinc3 you&#x27;ll choose one that&#x27;s max for both</li></ul><ul id="59a747e6-bc16-4351-a070-0612cd1b9e60" class="bulleted-list"><li style="list-style-type:disc">You can make heap in O(n) using make_heap</li></ul><ul id="7121e0d8-09e1-4863-a63e-5e887cb2122e" class="bulleted-list"><li style="list-style-type:disc">We can create a Min-Heap of size K and then compare the root of the Min-Heap with other elements and if it is greater than the root, then swap the value of the root and heapify the heap. This will help us to get the K largest elements in the end → basically we can always optimize heap questions from nlogn to nlogk</li></ul><ul id="b892c6d9-d839-4b90-bd74-1f6c892ad3d7" class="bulleted-list"><li style="list-style-type:disc">We can also use heap to rearrange letters such that no two consecutive characters are same<ul id="b8ca6715-cf52-486a-96c1-b74999f059db" class="bulleted-list"><li style="list-style-type:circle">we use pq to keep track of all the chars, length, and start adding max to the string</li></ul></li></ul><ul id="549de744-a3a0-4d72-bde8-73bb9878b36a" class="bulleted-list"><li style="list-style-type:disc">Priority Queue to find range</li></ul><pre id="7f095551-dd79-4c92-ba01-ef02ab3f368b" class="code"><code>#include &lt;bits/stdc++.h&gt;

int kSorted(vector&lt;vector&lt;int&gt;&gt; &amp;arr, int k, int n) {
    priority_queue&lt;
        pair&lt;int, pair&lt;int, int&gt;&gt;, 
        vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt;, 
        greater&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt;
    &gt; pq;

    int maxVal = INT_MIN;
    for(int i=0; i&lt;k; i++){
        pq.push({
            arr[i][0],
            { i, 0 }
        });
        maxVal = max(maxVal, arr[i][0]);
    }

    int minRangeStart = -1;
    int minRangeEnd = -1;
    int minRangeLength = INT_MAX;

    while(pq.size() == k){
        int val = pq.top().first;
        int vectorIndex = pq.top().second.first;
        int elementIndex = pq.top().second.second;
        pq.pop();

        if(maxVal - val &lt; minRangeLength){
            minRangeStart = val;
            minRangeEnd = maxVal;
            minRangeLength = maxVal - val;
        }

        if (elementIndex + 1 &lt; arr[vectorIndex].size()) {
            pq.push({arr[vectorIndex][elementIndex + 1], {vectorIndex, elementIndex + 1}});
            maxVal = max(maxVal, arr[vectorIndex][elementIndex + 1]);
        }
    }
    return minRangeLength + 1;
}</code></pre><h1 id="860841e7-0a1a-4a9a-a837-e1c915ff19d2" class="">Maps and Sets</h1><ul id="df79b355-fc31-4f1c-8898-7f2ece88d37a" class="bulleted-list"><li style="list-style-type:disc">Hash function can be letter + number</li></ul><ul id="f57b2ace-e07c-4c90-9a2d-8b8a6eb7dfe8" class="bulleted-list"><li style="list-style-type:disc">Next Palindrome<ul id="0a4d58d6-edc8-45ff-8bcd-97fccac16693" class="bulleted-list"><li style="list-style-type:circle">Case 1: If we have even number of digits, then we can have 1241 or we can have 1211
If we have 1211, we just replicate LHS in RHS in mirrored manner. If we have 1241, we increase the left-middle until the right middle and replicate them. If both are equal then we keep going until we find numbers which are not equal</li></ul><ul id="ae9478ab-081d-428a-a0d1-42546f001fd2" class="bulleted-list"><li style="list-style-type:circle">Case 2: If we have odd number of digits, then we can have 12345 and 12311
In the case of 12345, since left-to-middle is smaller than right-to-middle, increase middle and replicate. In the case of 12311, since left-to-middle is bigger, replicate the LHS in RHS in mirrored manner</li></ul><ul id="323581e6-63ba-4aa1-aceb-7946986d7687" class="bulleted-list"><li style="list-style-type:circle">Case 3: If you have 9 anywhere, then still we add 1 to it and continue using a carry</li></ul></li></ul><ul id="5e9d9776-b2dd-43ef-a269-bc92aaa30a92" class="bulleted-list"><li style="list-style-type:disc">When we have condition anywhere that i &lt; j then we can use maps to store j values and iterate through i and remove and solve the problem</li></ul><ul id="4f422ac5-f4be-46ab-9454-73ad0c02e091" class="bulleted-list"><li style="list-style-type:disc">Prefix Sum/XOR Question<ul id="b2c2ffe6-ef47-4170-b8dc-6db58864fca0" class="bulleted-list"><li style="list-style-type:circle">Logic is if you want subarray with sum m</li></ul><ul id="75f3ddc7-1bb3-4b9a-a8ef-e6372e984782" class="bulleted-list"><li style="list-style-type:circle">Then either prefix sum should be m or in the map of previous prefix sums, we should have total - m</li></ul><ul id="d2e88e6c-ff17-4086-820b-7a60d9a1e076" class="bulleted-list"><li style="list-style-type:circle">This gives us the total possible answers we need</li></ul></li></ul><ul id="db10d3da-2b5b-47c6-a137-bd387152418e" class="bulleted-list"><li style="list-style-type:disc">To find triangles with positive area, find all triangles and subtract those with same slope points</li></ul><ul id="e4f02a07-16ec-4656-b519-6e58304328eb" class="bulleted-list"><li style="list-style-type:disc">It directly checks the value of <code><strong>mp[mat[i][j]]</strong></code> to determine if the element has been encountered in the current row <code><strong>i</strong></code>. If the value is equal to <code><strong>i</strong></code>, it increments the count. However, this approach is less efficient because it involves multiple lookups in the map for each element, which can be computationally expensive. By using the map&#x27;s <code><strong>find()</strong></code> function in the first implementation, the algorithm avoids unnecessary lookups and achieves better performance</li></ul><h2 id="a5daf252-3a9b-4565-afba-890fc9fba00e" class="">Multiset</h2><ul id="98ca5b77-d04c-4459-b967-207ce3cfee52" class="bulleted-list"><li style="list-style-type:disc">Can contain multiple elements of same number but sorts them</li></ul><ul id="0e210e0b-def1-4fae-adef-959807e7f39f" class="bulleted-list"><li style="list-style-type:disc">We can use pointers which are iterators to access elements and this can help in problems where we have to get <span style="border-bottom:0.05em solid">median of sets of size K</span></li></ul><figure id="ba54e081-b698-4d6f-b232-1599b024eced" class="image"><a href="Lab%20Sheets%20and%20Notes%207b554b951577449fa210013fdf50ecf5/Untitled%201.png"><img style="width:1365px" src="Lab%20Sheets%20and%20Notes%207b554b951577449fa210013fdf50ecf5/Untitled%201.png"/></a></figure><h1 id="dfad1d4c-6cd6-4ecd-9095-bf0d84d46de3" class="">Divide and Conquer + Subarray Types</h1><ul id="61fecef4-073b-4804-8811-4bf7357261c5" class="bulleted-list"><li style="list-style-type:disc">Candle question<pre id="e409793a-cf91-4718-bc77-3f6b95958fd6" class="code code-wrap"><code>// We can make an array to keep track of previous plate and next plate I think 
 // so like say input is 
 // | | * * | | * * | * 
 // 0 1 2 3 4 5 6 7 8 9 
 // and given * is plate and | is candles 
 // we make an array of previous candle which will be A 
 // we make an array of next candle also which will be B 
 // we also make an array of how many plates wala prefix array C 
 // prevCandles = [0, 1, 1, 1, 4, 5, 5, 5, 8, 8] 
 // nextCandles = [0, 1, 4, 4, 4, 5, 8, 8, 8, -1] 
 // noOfPlates = [0, 0, 1, 2, 2, 2, 3, 4, 4, 5] 
 // Now query is 3, 8 -&gt; we find where the nearest candle in nextCandles to 3 -&gt; 4 
 // find the previous candle for 8 -&gt; 8 
 // Now we find theprefixSum[8] - theprefixSum[4] = 4 - 2 
  
 // Total TC = O(3n + q) = O(n + q)</code></pre></li></ul><ul id="2bd4e0a4-6f42-4a35-a104-c2c75ff6bddd" class="bulleted-list"><li style="list-style-type:disc">Sub array differences <pre id="927b7921-7140-49a1-aae9-ea72ffbbcecf" class="code code-wrap"><code>// let&#x27;s say we have a b c d e f  
// sub array differences will be   
// Sigma(subarrays) Max - Min = Sigma(subarrays) Max - Sigma(subarrays) Min  
// Now for Sigma(subarrays) Max we use a stack  
// so like if we have 4 6 5, to find the number of subarrays with 4 as minimum, we use a stack  
// such that we get previous greater element and next greater element  
// similarly for maximum, we use previous smaller and next smaller element concept :)    
// sum of mins for 4 5 6 = 4 + 4 + 4 + 5 + 5 + 6 = 28</code></pre></li></ul><ul id="2d441a4f-64e5-4cdc-8e89-514f728eb4bd" class="bulleted-list"><li style="list-style-type:disc">Number of sub array with given average k → subtract k from all the numbers such that average will become 0 and now all you have to do is use prefix sum to get subarrays which have 0 sum</li></ul><ul id="b4390c13-a1c3-44fa-a181-24e7a239232b" class="bulleted-list"><li style="list-style-type:disc">Kadane’s Algorithm<ul id="3d92877e-54a3-46ae-98e7-348bbb084235" class="bulleted-list"><li style="list-style-type:circle">Works for both +ve and -ve</li></ul></li></ul><ul id="c00cbbd0-1686-4379-8259-6a95643404dd" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.youtube.com/watch?v=NTop3VTjmxk">Median of two Sorted Arrays of Different Sizes | Binary Search - YouTube</a></li></ul><ul id="57a97aa9-4681-4482-8deb-45fe347c7e6a" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.geeksforgeeks.org/pancake-sorting/">Pancake sorting - GeeksforGeeks</a></li></ul><h1 id="6576cc29-64ff-476e-bd89-c990aaf63f94" class="">Greedy Algorithm</h1><ul id="7c90dd97-24d3-4333-80fd-746242f9c128" class="bulleted-list"><li style="list-style-type:disc">Maximum Meetings → Try to put as small meetings together as possible</li></ul><ul id="643ebfaf-da12-40fc-91aa-06720920eed1" class="bulleted-list"><li style="list-style-type:disc">Not same as minimum platforms: the logic here is that we can use 2 pointers to just keep track of trains departure times and arrival times<ul id="bdf328c5-8ce4-4e01-8df2-69484a325ac7" class="bulleted-list"><li style="list-style-type:circle">We need to sort both arrival and departure times and then maintain count if arrival is less than or equal to departure meaning there&#x27;s a need for extra platform else </li></ul><pre id="dd51888b-cf19-4d43-b3bc-bcc33ae429a2" class="code"><code>#include &lt;algorithm&gt;

int calculateMinPatforms(int at[], int dt[], int n) {
    // Sort both the arrays.
    sort(at, at + n);
    sort(dt, dt + n);

    // Indicates the number of platforms needed at a time.
    int curNumOfPlatforms = 0;

    // Variable to store the final answer i.e. minimum number of platforms required.
    int minNumOfPlatforms = 0;

    int i = 0, j = 0;

    while (i &lt; n &amp;&amp; j &lt; n) {

        // If the next event in sorted order is arrival, increment count of platforms needed.
        if (at[i] &lt;= dt[j]) {
            curNumOfPlatforms++;
            i++;
        }

        // Else decrement count of platforms needed.
        else {
            curNumOfPlatforms--;
            j++;
        }

        // Update minimum number of platforms.
        minNumOfPlatforms = max(minNumOfPlatforms, curNumOfPlatforms);
    }

    // Return the minimum number of platforms.
    return minNumOfPlatforms;
}</code></pre></li></ul><h1 id="22b08bc7-bbb1-4df4-9d49-db445319d5c3" class="">Dynamic Programming</h1><ul id="70383ac3-7674-4f7b-a7b1-786ad5725627" class="bulleted-list"><li style="list-style-type:disc">Whenever greedy fails, try all possible ways using recursion and then shift to dynamic programming</li></ul><ul id="914b48cc-c784-441b-83a5-d484077f4175" class="bulleted-list"><li style="list-style-type:disc">Knapsack problems based on limits also<ul id="2fa57c64-baa4-4fbe-8912-e03a2a765ea3" class="bulleted-list"><li style="list-style-type:circle">DP will not work if 10^4 is the limit and you try O(n^2) need to think of maybe greedy or something</li></ul></li></ul><ul id="68819f95-c494-4c0d-9d6b-21c544853442" class="bulleted-list"><li style="list-style-type:disc">Longest common subsequence, here if same, then we go backwards else go backwards on both ends and take max. Here if same we add</li></ul><ul id="28d61cf0-77b6-4f8e-b681-bdade9274ee6" class="bulleted-list"><li style="list-style-type:disc">Longest common palindrome is lcs between string and reverse(string) → Longest Palindromic Subsequence :)<ul id="0754d5dd-1f9e-46d1-bf4c-e5bd4cfaa5fa" class="bulleted-list"><li style="list-style-type:circle">When they ask minimum insertions for palindrome that is totalLength - LPS</li></ul></li></ul><ul id="f5e0b241-5a8d-4fb7-b29c-b5a67e16f5b7" class="bulleted-list"><li style="list-style-type:disc">Edit Distance means we take a, b → min(a-1, b | a, b-1 | a-1, b-1). Here if same then we don’t add</li></ul><ul id="972e574a-4b4d-4976-b3fd-f8ee9468c7f3" class="bulleted-list"><li style="list-style-type:disc">Distinct Subsequences<pre id="2fd21f5f-1fba-4465-9d64-c77e21b80420" class="code"><code>int distinctSubsequences(string S) 
{
    int n = S.length();
    vector&lt;long long&gt; lastOccurence(256, -1);

    long long dp[n+1];
    dp[0] = 1;
    for(int i=1; i&lt;=n; i++){
        dp[i] = (2*dp[i-1]) % mod;

        if(lastOccurence[S[i]] != -1){
            dp[i] -= dp[lastOccurence[S[i]]];
        }

        lastOccurence[S[i]] = i;
    }

    return dp[n]%mod &gt; 0 ? dp[n]%mod : dp[n]%mod + mod;
}</code></pre></li></ul><ul id="ecac6f0c-b60a-4d37-a5e4-7afe1a17ff94" class="bulleted-list"><li style="list-style-type:disc">Weighted Job Scheduling - This has DP also greedy also</li></ul><ul id="e751e150-b559-4cf1-bc94-1c3ef42f42d1" class="bulleted-list"><li style="list-style-type:disc">Longest Bitonic Subsequence → Increasing + Decreasing, or Increasing or Decreasing Subsequence<ul id="d64852d5-9337-48c3-a39d-d693f4a961ac" class="bulleted-list"><li style="list-style-type:circle">Take LIS from left side, and LIS from right side </li></ul><ul id="52c0e7cc-f612-41db-ae87-3d82a17b3d92" class="bulleted-list"><li style="list-style-type:circle">Take max(LIS_Left[i] + LIS_Right[i] - 1)</li></ul></li></ul><ul id="d502260c-1342-4b8e-b1a8-d48b0f1b5efc" class="bulleted-list"><li style="list-style-type:disc">In counting questions in partitions , base case will return 1 or 0 and then we add the results say pick + not pick</li></ul><ul id="d09ce21a-bd32-4251-9a78-cfbb877e26c7" class="bulleted-list"><li style="list-style-type:disc">Partition to K equal sum subsets → need not use DP cause no overlapping subproblems, but we will get recursion and very high complexity or maybe we can use bit masking</li></ul><ul id="e8666861-343a-4f72-890d-01b9db654f43" class="bulleted-list"><li style="list-style-type:disc">Count Partitions with Given difference → this is basically subset sum with target = (difference + total sum)/2<ul id="5a775bbc-7efe-470e-bbf7-e22dad02a09f" class="bulleted-list"><li style="list-style-type:circle">Because s1 + s2 = total sum</li></ul><ul id="28c1355b-ddf7-452a-965b-9fdeb974509f" class="bulleted-list"><li style="list-style-type:circle">s1-s2 = difference and from here we take s1 ka equation</li></ul></li></ul><ul id="e51f46ec-088a-4e09-afbd-5077401b1913" class="bulleted-list"><li style="list-style-type:disc">Game Winning Type Questions: <pre id="b0a18eb5-0d46-436e-947c-995ce3619aeb" class="code code-wrap"><code>// If I take start, the opponent can choose start+1 
// which will lead to my next choice being in start+2:end or opponent can choose end
// my choice will then be start+1:end-1
int ifWeTakeStart = input[start] + min(blessings(input, start+2, end), blessings(input, start+1, end-1));
int ifWeTakeEnd = input[end] + min(blessings(input, start+1, end-1), blessings(input, start, end-2));

return dp[start][end] = max(ifWeTakeStart, ifWeTakeEnd);D</code></pre></li></ul><ul id="ae91e35d-20d1-4a9b-88b5-b7b82ef5811f" class="bulleted-list"><li style="list-style-type:disc">Matrix Chain Questions: <em> </em><code><em>C(i, j) = min(C(i, k-1) + C(k, j) + l_i*l_k-1*l_j)</em></code></li></ul><ul id="b10f585a-9029-4af7-8740-f578d6fbb4c4" class="bulleted-list"><li style="list-style-type:disc">Check brackets without stack using DP: I mean that’s technically not useful but ok let’s see<ul id="21b05831-fb27-465d-9d8b-16f836b80a35" class="bulleted-list"><li style="list-style-type:circle">We iterate through the string</li></ul><ul id="77d7d15b-89a4-4096-8e6d-248ffbce3b1e" class="bulleted-list"><li style="list-style-type:circle">we check if it&#x27;s a closing bracket and if the one before is a opening bracket, then it will become part of the largest string + these 2 characters</li></ul><ul id="4ccb662f-6f76-4007-beb1-6ac9cd83a8fa" class="bulleted-list"><li style="list-style-type:circle">then we check if the previous one is also a closing bracket, then we have a check to see if the DP[i-1] which means the largest RBS till there, is less than i </li></ul><ul id="e05289ce-c199-445e-8b3f-101e70caea7e" class="bulleted-list"><li style="list-style-type:circle">we also check if there&#x27;s an rbs like that then, does it start with a opening bracket. if yes then DP[curr] = dp[the word - the curr] + dp[]. In conclusion, this is basically checking if it has an opening bracket before</li></ul><pre id="65a5ac01-d490-4619-9231-b3a604a765f2" class="code"><code>if (input[i] == &#x27;)&#x27;)
{
    if (input[i - 1] == &#x27;(&#x27;)
    {
        dp[i] = (i &gt;= 2 ? dp[i - 2] : 0) + 2;
    }
    else if (input[i - 1 - dp[i - 1]] == &#x27;(&#x27;)
    {
				int prev = dp[i-1];
        dp[i] = prev + (i - prev &gt;= 2 ? dp[i - prev - 2] : 0) + 2;
    }

    maxans = max(maxans, dp[i]);
}</code></pre></li></ul><ul id="e0e7f530-b25e-4a07-a956-bd911a5f58f2" class="bulleted-list"><li style="list-style-type:disc">In case of circular DP where we have to ignore left most or right most, we just create two new vectors and solve on these two<pre id="360b2a41-32fb-4ccf-9440-226d784b5bc0" class="code code-wrap"><code>𝐃𝐲namic Programming
Pattern -&gt;𝟏𝐃 𝐃𝐲𝐧𝐚𝐦𝐢𝐜 𝐏𝐫𝐨𝐠𝐫𝐚𝐦𝐦𝐢𝐧𝐠
1) Climbing Stairs
2) Frog Jump
3) Frog Jump with K
4) Maximum sum of Non-adjacent elements
5) House robber 2
6) Ninja&#x27;s Training

Pattern -&gt; 𝐃𝐲𝐧𝐚𝐦𝐢𝐜 𝐏𝐫𝐨𝐠𝐫𝐚𝐦𝐦𝐢𝐧𝐠 𝐎𝐧 𝐆𝐫𝐢𝐝𝐬 / 𝟐𝐃
1) Grid Unique Paths
2) Unique Paths
3) Minimum path sum in Grid
4) Triangle (Fixed Starting Point and Variable Ending Point)
5) Minimum/Maximum Falling Path Sum
6) Cherry Pickup 2

Pattern -&gt; 𝐃𝐲𝐧𝐚𝐦𝐢𝐜 𝐏𝐫𝐨𝐠𝐫𝐚𝐦𝐦𝐢𝐧𝐠 𝐎𝐧 𝐒𝐮𝐛𝐬𝐞𝐭𝐬 / 𝐒𝐮𝐛𝐬𝐞𝐪𝐮𝐞𝐧𝐜𝐞
1) Subset Sum Equals to Target
2) Partition Equals Subset Sum
3) Partition A subset into 2 subset with minimum absolute sum diff.
4) Count Subsets With Sum K
5) Count Partitions with given difference
6) 0/1 Knapsack
7) Minimum Coins
8) Target Sum
9) Coin Change 2
10) Unbounded Knapsack 1 D array
11) Rod Cutting 1 D array

Pattern -&gt; 𝐃𝐲𝐧𝐚𝐦𝐢𝐜 𝐏𝐫𝐨𝐠𝐫𝐚𝐦𝐦𝐢𝐧𝐠 𝐎𝐧 𝐒𝐭𝐫𝐢𝐧𝐠𝐬
1) Print Length Of Longest Common Subsequence
2) Print Longest Common Subsequence
3) Longest Palindromic Subsequence
4) Minimum Insertion to Make String Palindrome
5) Minimum Insertions/Deletions to Convert String A -&gt; B
6) Shortest Common SuperSequence
7) Distinct Subsequence
8) Edit Distance
9) Wildcard Matching

Pattern -&gt; 𝐃𝐲𝐧𝐚𝐦𝐢𝐜 𝐏𝐫𝐨𝐠𝐫𝐚𝐦𝐦𝐢𝐧𝐠 𝐎𝐧 𝐒𝐭𝐨𝐜𝐤𝐬
1) Best Time To Buy and Sell Stock (Buy Ones &amp; Sell Ones )
2) Best Time To Buy and Sell Stock 2 (Unlimited Time Buy &amp; Sell)
3) Best Time To Buy and Sell Stock 3 ( At Max 2 Times Buy &amp; Sell)
4) Best Time To Buy and Sell Stock 4 (K times Buy &amp; Sell )
5) Best Time To Buy and Sell Stock 5 (Buy &amp; Sell With Cooldown)
6) Best Time To Buy and Sell Stock 6 (Buy &amp; Sell With Extra Fee)

Pattern -&gt; 𝐃𝐲𝐧𝐚𝐦𝐢𝐜 𝐏𝐫𝐨𝐠𝐫𝐚𝐦𝐦𝐢𝐧𝐠 𝐎𝐧 𝐋𝐨𝐧𝐠𝐞𝐬𝐭 𝐈𝐧𝐜𝐫𝐞𝐚𝐬𝐢𝐧𝐠 𝐒𝐮𝐛𝐬𝐞𝐪𝐮𝐞𝐧𝐜𝐞 (LIS)
1) Print Length Of Longest Increasing Subsequence
2) Print Longest Increasing Subsequence
3) Largest Divisible Subset
4) Longest String chain
5) Longest Bitonic Subsequence
6) Number Of Longest Increasing Subsequence

Pattern -&gt; 𝐇𝐚𝐫𝐝𝐞𝐬𝐭 𝐃𝐲𝐧𝐚𝐦𝐢𝐜 𝐏𝐫𝐨𝐠𝐫𝐚𝐦𝐦𝐢𝐧𝐠 𝐎𝐧 𝐩𝐚𝐫𝐭𝐢𝐭𝐢𝐨𝐧
1) Matrix Chain Multiplication
2) Minimum Cost To cut The Stick
3) Burst Balloons
4) Evaluate Boolean
5) Palindrome Partitioning 2
6) Partition Array For Maximum Sum
7) Maximum Rectangle Area with all 1&#x27;s (Dp on Rectangle)
8) Count Square Submatrices with all ones (Dp on Rectangle)</code></pre></li></ul><ul id="4d4bbb37-a525-484f-b9fe-0b0ed0ef79d0" class="bulleted-list"><li style="list-style-type:disc">In best time to buy and sell stock, we can keep track of buy or sell status with an extra variable in the function</li></ul><ul id="1df9c797-4329-4313-97de-4239f481aa5d" class="bulleted-list"><li style="list-style-type:disc">Colorful knapsack<pre id="2eb9d8a6-f606-4d60-a0b2-1a759e7827e3" class="code code-wrap"><code>#include &lt;bits/stdc++.h&gt;

int solve(int idx , int target , int m ,unordered_map&lt;int,vector&lt;int&gt;&gt; &amp;col,vector&lt;vector&lt;int&gt;&gt; &amp;dp){
    if(idx==m+1){
      return 0
    }

    if(target&lt;=0){
        return INT_MIN;
    }

    if(dp[idx][target]!=-1){
        return dp[idx][target];
    }

    int curr = INT_MIN;

    for(auto i:col[idx]){
        curr = max(curr,i+solve(idx+1,target-i,m,col,dp));
    }

    return dp[idx][target] = curr;
}

int colorfulKnapsack(int w[], int c[], int n, int m, int x){
    unordered_map&lt;int,vector&lt;int&gt;&gt; col;
    vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt; (x+1,-1));
    for(int i=0;i&lt;n;i++){
        col[c[i]].push_back(w[i]);
    }
    int ans = solve(1,x,m,col,dp);
    if(ans&lt;0) return -1;
    if(x-ans&lt;=0) return 0;
    return x-ans;
}</code></pre></li></ul><ul id="cccbede8-5152-4f50-aa63-748f53b56765" class="bulleted-list"><li style="list-style-type:disc">Partition DP:<ul id="db6c4824-f900-4c05-b10e-356a96db996a" class="bulleted-list"><li style="list-style-type:circle">Mostly will involve for loops inside the DP</li></ul><ul id="8aad993b-bcfe-4d95-9dcd-0dbb8241d32b" class="bulleted-list"><li style="list-style-type:circle">Minimum Cost to cut the stick, we push 0 and n</li></ul><ul id="b6f240f4-3fbc-453c-9b54-1d33f6fe7eea" class="bulleted-list"><li style="list-style-type:circle">Burst Balloons → In this question we have a b c d balloons and we need to pop balloons, every time we pop, we get left*curr*right number of coins<ul id="96c05018-4c1e-41ee-a032-6b04550f51ef" class="bulleted-list"><li style="list-style-type:square">We cannot go from a b c d → a b c because these are not independent of each other</li></ul><ul id="7f90652b-713d-422d-b16d-b2d8dd11438b" class="bulleted-list"><li style="list-style-type:square">but we can go from 0 to full because, let’s say you pop a last, that means last second mein pakka a is there</li></ul><ul id="cb6a32a3-cebe-4fee-a8d0-39c63e49cd7b" class="bulleted-list"><li style="list-style-type:square">We push 1 to the left and 1 to the right and use similar solution to minimum cost to cut the stick</li></ul></li></ul></li></ul><ul id="02a65b3e-28ca-4dab-bef9-310e2be6dc45" class="bulleted-list"><li style="list-style-type:disc">Boolean Evaluation<pre id="bf888209-a848-4f64-a20b-ae4cc5d4f29e" class="code"><code>long long evaluate(vector&lt;vector&lt;vector&lt;long long&gt;&gt;&gt; &amp;dp, string &amp;exp, int i, int j, int isTrue){
    if(i &gt; j) return 0;

    if(i == j &amp;&amp; isTrue) return exp[i] == &#x27;T&#x27;;
    else if(i == j &amp;&amp; !isTrue) return exp[i] == &#x27;F&#x27;;

    if(dp[i][j][isTrue] != -1) return dp[i][j][isTrue]%mod;

    long long ways = 0;

    for(int p = i + 1; p &lt;= j - 1; p += 2){
        char op = exp[p];

        long long lT = dp[i][p-1][1] = evaluate(dp, exp, i, p-1, 1)%mod;
        long long lF = dp[i][p-1][0] = evaluate(dp, exp, i, p-1, 0)%mod;
        long long rT = dp[p+1][j][1] = evaluate(dp, exp, p+1, j, 1)%mod;
        long long rF = dp[p+1][j][0] = evaluate(dp, exp, p+1, j, 0)%mod;

        if(isTrue){
            if(op == &#x27;&amp;&#x27;){
                ways += (lT*rT)%mod;
            }else if(op == &#x27;|&#x27;){
                ways += ((lT*rT)%mod + (lT*rF)%mod + (lF*rT)%mod)%mod;
            }else if(op == &#x27;^&#x27;){
                ways += ((lT*rF)%mod + (lF*rT)%mod)%mod;
            }
        } else {
            if(op == &#x27;&amp;&#x27;){
                ways += ((lT*rF)%mod + (lF*rT)%mod + (lF*rF)%mod)%mod;
            }else if(op == &#x27;|&#x27;){
                ways += (lF*rF)%mod;
            }else if(op == &#x27;^&#x27;){
                ways += ((lT*rT)%mod + (lF*rF)%mod)%mod;
            }
        }
    }   
    return dp[i][j][isTrue] = ways%mod;     
}</code></pre></li></ul><h3 id="df1cf2ac-c22b-4460-b555-f6bde43b6a3f" class="">Converting Memoization to Tabulation</h3><ul id="9e8e8de8-03d2-4138-9ec4-e723b4108974" class="bulleted-list"><li style="list-style-type:disc">Copy the base case</li></ul><ul id="994a0145-d579-4a46-a591-fa35d546a4b1" class="bulleted-list"><li style="list-style-type:disc">Reverse the iteration for the variables. If you are calling recursion with 0, then iteration should start with n</li></ul><ul id="d63e6a4b-9aa9-495f-89eb-6d4275c27083" class="bulleted-list"><li style="list-style-type:disc">Copy recurrence</li></ul><h1 id="fb9cf0a0-22ac-4034-96b4-69e5cfb40711" class="">Tries</h1><ul id="555fe9d2-386b-47d9-82eb-f829ec4b5a9e" class="bulleted-list"><li style="list-style-type:disc">Implement Trie matlab we use node where each node has an array of nodes</li></ul><ul id="5b07c849-30da-453d-9d72-d904a00762ef" class="bulleted-list"><li style="list-style-type:disc">Erase might be pain but I realized yesterday we don’t have to free and stuff in erase, if we subtract, that is fine</li></ul><ul id="6e80fff4-d5ea-457a-bc0d-0db2b1634066" class="bulleted-list"><li style="list-style-type:disc">Distinct Substrings → We can use trie <ul id="3630f3c1-5c69-4dfd-8c08-c8c9fb3ff0ea" class="bulleted-list"><li style="list-style-type:circle">Basically the advantage with trie here is that we don’t need to store abab and aba separately</li></ul><ul id="b50e9745-4ff5-4adf-9220-466708e1a3fa" class="bulleted-list"><li style="list-style-type:circle">So space complexity reduces because we are not storing all of them separately</li></ul></li></ul><ul id="6ab3f2ce-4486-46d7-b19f-d7e0fc617de8" class="bulleted-list"><li style="list-style-type:disc">Max XOR → you store all numbers in trie and iterate for each of them the opposite bit</li></ul><h1 id="c93f1865-b14e-42b4-ab4d-a9550127a21b" class="">Graphs BFS + DFS</h1><ul id="cbfb6df6-d4c3-416f-8ef5-19fc91073965" class="bulleted-list"><li style="list-style-type:disc">Flood fill → just use BFS → BFS Always gives shortest path</li></ul><ul id="190ee265-e668-40b1-a134-260ce1d11ab4" class="bulleted-list"><li style="list-style-type:disc">Finding number of islands → iterative flood fill</li></ul><ul id="a5678337-51b9-402f-be10-4e8be87f3393" class="bulleted-list"><li style="list-style-type:disc">Bipartite graphs also we can use BFS, bipartite is where we can color the graph in two colors such that no two adjacent nodes have same color</li></ul><ul id="4b50455d-6b4a-4c61-b88e-b72205abb34f" class="bulleted-list"><li style="list-style-type:disc">Topological Sort → If there is an edge between u and v, u appears before v in the sorted sequence → We use DFS and BFS<ul id="1231bf28-b268-42ad-89b5-d1bcd6ff2196" class="bulleted-list"><li style="list-style-type:circle">In DFS method we keep going depth first and marking as visited and push nodes into stack with the adjacent nodes being sent first. When we reverse we get topo order</li></ul><ul id="e8dd9ece-6d47-4fa1-8bbe-44fab3b178f9" class="bulleted-list"><li style="list-style-type:circle">NOTE: Currently, you are passing the <code><strong>adjList</strong></code> vector by value, which means that a copy of the vector is created each time the <code><strong>dfs</strong></code> function is called. This can lead to excessive memory usage and slower execution, especially if the graph is large</li></ul></li></ul><h3 id="c83a2950-b220-4fab-8bcd-141fd495e7ea" class="">Bridges in Graphs</h3><ul id="88d8ce32-551c-47bb-bb2e-82ff73b75536" class="bulleted-list"><li style="list-style-type:disc">Bridge is that edge which, if removed, breaks the graph into two separate components.</li></ul><ul id="9da00649-1874-4e3f-a5cc-753fc21aa8b3" class="bulleted-list"><li style="list-style-type:disc">We will use DFS with some extra variables</li></ul><ul id="1627946f-0d3c-48dc-a351-fd2f7f5d2564" class="bulleted-list"><li style="list-style-type:disc">We will use two separate arrays, tin (time of insertion) and low the lowest time of insertion apart from parent</li></ul><ul id="e384682d-fa78-4e65-ada2-64a65fc3e9d9" class="bulleted-list"><li style="list-style-type:disc">The logic is that if we are able to reach a node earlier than a previous node that means there is no bridge at that point</li></ul><pre id="98217f93-d9b3-45e2-9b4f-bc7e92f089ee" class="code"><code>int timer = 1;

void dfs(int node, int parent, vector&lt;int&gt; &amp;visited, vector&lt;vector&lt;int&gt;&gt; &amp;adjEdges, vector&lt;int&gt; &amp;tin, vector&lt;int&gt; &amp; low, vector&lt;vector&lt;int&gt;&gt; &amp;bridges){
    visited[node] = 1;
    tin[node] = low[node] = timer;
    timer++;

    for(auto edge: adjEdges[node]){
        if(edge == parent) continue;
        if(visited[edge] == 0){
            dfs(edge, node, visited, adjEdges, tin, low, bridges);
            low[node] = min(low[edge], low[node]);

            if(low[edge] &gt; tin[node]){
                bridges.push_back({ edge, node });
            }
        }else{
            low[node] = min(low[edge], low[node]);
        }
    }
}


vector&lt;vector&lt;int&gt;&gt; findBridges(vector&lt;vector&lt;int&gt;&gt; &amp;edges, int v, int e) {
    // Write your code here
    vector&lt;vector&lt;int&gt;&gt; adjEdges(v, vector&lt;int&gt; ());
    for(auto x: edges){
        adjEdges[x[0]].push_back(x[1]);
        adjEdges[x[1]].push_back(x[0]);
    }

    vector&lt;int&gt; visited(v, 0);
    vector&lt;int&gt; tin(v);
    vector&lt;int&gt; low(v);

    vector&lt;vector&lt;int&gt;&gt; bridges;

    for(int i=0; i&lt;v; i++){
        if(!visited[i]){
            dfs(i, -1, visited, adjEdges, tin, low, bridges);
        }
    }
    return bridges;
}</code></pre><h3 id="e42fd81c-f33a-4f9a-af9e-c72edb3cafb1" class="">Kahn’s Algorithm: BFS in topo sorting</h3><ul id="dfc6d7fe-6f3a-4e14-b6b3-eb778b3eb6e1" class="bulleted-list"><li style="list-style-type:disc">This is important when you need level order traversal</li></ul><ul id="c26cd759-d3ac-46ce-bf79-b4b5b389e97c" class="bulleted-list"><li style="list-style-type:disc">In this we first make an array of in count for each node that counts the number of edges going into this node</li></ul><ul id="2bdb104d-a3aa-4c82-b1bd-8e455499c63a" class="bulleted-list"><li style="list-style-type:disc">Then, we make a queue and send all those with in count = 0 in to the queue, and then when we take the top most from queue, we subtract that node from all the other nodes ka in count and if it’s 0 again added to the queue</li></ul><ul id="6340fe28-b47a-47c1-86cc-d5dcab110f0e" class="bulleted-list"><li style="list-style-type:disc">if topo sort contains n elements no cycle else cycle</li></ul><h3 id="d4be0dfe-ba9a-4c19-b4fd-5ac9df75bc8d" class="">Dijkstra’s Algorithm → E Log V</h3><ul id="dd0f5bd7-66d5-46df-8a74-8d21eaa40b5b" class="bulleted-list"><li style="list-style-type:disc">We can use priority queue or set, set is faster. We store pairs of destination node and distance in the adjacency list</li></ul><ul id="ceb3fbf9-7d68-4cee-aea6-6d402c3806d8" class="bulleted-list"><li style="list-style-type:disc">Then we use priority queue, and start with { 0, 0 } and keep going using the adjacency lists<pre id="b8020277-8120-412b-a2a4-c14c0f2da665" class="code"><code>	  vector&lt;int&gt; ans(vertices, INT_MAX);
    ans[source] = 0;

    priority_queue&lt;
        pair&lt;int, int&gt;, 
        vector&lt;pair&lt;int, int&gt;&gt;, 
        greater&lt;pair&lt;int, int&gt;&gt;
    &gt; pq;
		vector&lt;int&gt; parent(n);
		for(int i=1; i&lt;=n; i++) parent[i] = i;

    pq.push({ 0, source });

    while(!pq.empty()){
        int distTillHere = pq.top().first;
        int node = pq.top().second;
        pq.pop();

        for(auto ed: adjList[node]){
            int edgeWeight = ed.second;
            int adjNode = ed.first;

            if(distTillHere + edgeWeight &lt; ans[adjNode]){
                ans[adjNode] = distTillHere + edgeWeight;
                pq.push({ distTillHere + edgeWeight, adjNode });
								// for parent -&gt; parent[adjNode] = node;
            }
        }
    }</code></pre></li></ul><ul id="b72631a2-80c2-46ff-a120-abe24e531d52" class="bulleted-list"><li style="list-style-type:disc">If we have to find the path itself, we use memoization and add that to the previous code, we basically use a extra vector named parent which keeps track of from where you have come</li></ul><ul id="fc11e206-db60-476a-94da-dad43c69c0bc" class="bulleted-list"><li style="list-style-type:disc">Time Complexity → E Log V = V^2 Log V</li></ul><ul id="18aa5ac0-1d45-42b4-b7d8-38ca1b965663" class="bulleted-list"><li style="list-style-type:disc">Cheapest flights with K stops → Dijkstra but modified to take stops, distance and cost in the PQ</li></ul><h3 id="0fcd1094-a4f8-472a-87ce-5c8ad7b2d1aa" class="">Bellman Ford O(n*m)</h3><ul id="a56c068f-ceb2-4c86-98c9-8279cda7e2ea" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid">Dijkstra’s fails when graph has negative edges or if we have a negative cycle</span>, then we will go to TLE</li></ul><ul id="1ae928c8-220d-4028-8d2a-af642aa95926" class="bulleted-list"><li style="list-style-type:disc">Helps you to detect negative cycles as well but only applicable for <span style="border-bottom:0.05em solid">directed graphs</span></li></ul><ul id="3eed7dfe-039f-4e21-baab-86ef26b307a3" class="bulleted-list"><li style="list-style-type:disc">If we have undirected graph, we can just introduce 2 edges in that place</li></ul><ul id="b8634e92-821f-4730-8e84-29ffd93be53d" class="bulleted-list"><li style="list-style-type:disc">Relax all edges n-1 times sequentially → Relax is updating the distance if you get a lower distance</li></ul><ul id="c343e7f9-6e7c-4488-a6ef-8fdac807f2d6" class="bulleted-list"><li style="list-style-type:disc">Edge order does not matter but we go edge wise. In each iteration we update all the edges and relax them</li></ul><ul id="0112db5e-f69c-4c86-bd5c-96a79f1a25de" class="bulleted-list"><li style="list-style-type:disc">why n-1? → because all of them won’t be updated until the n-1th round in worst case scenario.</li></ul><ul id="0675b21b-cff1-4039-9108-d79bab44c12b" class="bulleted-list"><li style="list-style-type:disc">But if we do for say n times, and if the distance changes then we prove that negative cycle exists </li></ul><pre id="aa4b650f-2f5d-4721-8703-54a719fdab30" class="code"><code>		vector&lt;int&gt; dist(n+1, 1e9);
    dist[src] = 0;

    for(int i=1; i&lt;=n-1; i++){
        for(auto edge: edges){
            int u = edge[0];
            int v = edge[1];
            int w = edge[2];

            if(dist[u] != 1e9 &amp;&amp; dist[u] + w &lt; dist[v]){
                dist[v] = dist[u] + w;
            }
        }
    }

    return dist[dest];</code></pre><h3 id="e79e60ee-2010-47d3-9eae-4f5d2d6a3e49" class="">Floyd Warshall - Multiple Sources and Destinations</h3><ul id="90321f10-5331-4b11-9483-63ec49821f19" class="bulleted-list"><li style="list-style-type:disc">Useful for finding paths between multiple sources and destinations</li></ul><ul id="59faf88b-aff6-435a-9c22-583db53b8a14" class="bulleted-list"><li style="list-style-type:disc">We don’t use adjList here</li></ul><ul id="7898739d-b1a9-4bac-97db-1f593a0bd93e" class="bulleted-list"><li style="list-style-type:disc">We prefer using adjacency matrix method <ul id="d09f288e-4587-4e97-b79e-33dcc67892eb" class="bulleted-list"><li style="list-style-type:circle">DP[i][i] = 0;</li></ul><ul id="33ef8373-2228-4b7f-96da-d90997ea8e60" class="bulleted-list"><li style="list-style-type:circle">and store all nodes</li></ul><ul id="2b6e8b57-17ae-4fc7-bc4b-f8ef7a3a3838" class="bulleted-list"><li style="list-style-type:circle">others, we put infinity</li></ul></li></ul><ul id="0aad416f-46ce-4450-b729-62637314ff14" class="bulleted-list"><li style="list-style-type:disc">We iterate through all the nodes per every node → so like n^2 * n = n^3</li></ul><ul id="eb2ccaaf-008a-430b-beaf-3948f4c6c33c" class="bulleted-list"><li style="list-style-type:disc">Detect negative cycles if DP[i][i] &lt; 0</li></ul><ul id="3e4a8ae4-2a70-4ad5-9239-93ff881e06f1" class="bulleted-list"><li style="list-style-type:disc">Find the City With the Smallest Number of Neighbors at a Threshold Distance<pre id="0b1db5f9-40cd-4fcc-8ea5-f870ba6086da" class="code"><code>for(auto edg: edges){
		adjMat[edg[0]][edg[1]] = edg[2];
		adjMat[edg[1]][edg[0]] = edg[2];
	}

	for(int node=0; node&lt;n; node++){
		for(int i=0; i&lt;n; i++){
			for(int j=0; j&lt;n; j++){
				adjMat[i][j] = min(
					adjMat[i][j],
					adjMat[i][node] + adjMat[node][j]
				);
			}
		}
	}</code></pre></li></ul><h1 id="09145549-c60a-4ebb-b106-848609ea569d" class="">Disjoint Set Data Structure - O(4 Alpha)</h1><ul id="75c38ced-4ce3-4258-bbb0-ce391939402c" class="bulleted-list"><li style="list-style-type:disc">Helpful when you have to tell if there is a path between two nodes in constant time</li></ul><ul id="4f1d8006-0ca2-45e6-b3a6-62270fa5f5df" class="bulleted-list"><li style="list-style-type:disc">This is a data structure and has 3 functions<ul id="1cb81465-2fea-45bb-a4b6-a5e75a7860fd" class="bulleted-list"><li style="list-style-type:circle">Find Parent</li></ul><ul id="078f5078-d518-4d1a-8c07-26294bf0b1a3" class="bulleted-list"><li style="list-style-type:circle">Union() based on rank</li></ul><ul id="66b11832-62fc-45e2-948c-be68b194a836" class="bulleted-list"><li style="list-style-type:circle">Union() based on size: for size default size would be 1</li></ul></li></ul><ul id="bfefb588-98a2-44e2-9715-01609013e424" class="bulleted-list"><li style="list-style-type:disc">Very useful in dynamic graphs</li></ul><ul id="388517ab-02bd-448e-82eb-9d142203d8a7" class="bulleted-list"><li style="list-style-type:disc">We need rank array (default is 0) and parent array (default is the same value as index (1-based))</li></ul><ul id="ef2fa3cf-ff3d-4f53-8b05-f479ca06397d" class="bulleted-list"><li style="list-style-type:disc">Union(u, v)<ul id="816da6a4-4bc4-47c0-bfeb-01dd990ba497" class="bulleted-list"><li style="list-style-type:circle">find ultimate parent of u, and v, parent-u and parent-v</li></ul><ul id="6dc6be8e-304a-4c91-bfac-7d543537fa00" class="bulleted-list"><li style="list-style-type:circle">Find rank of parent-u, parent-v</li></ul><ul id="270b712c-67d0-4733-a838-4f51e12bb7e2" class="bulleted-list"><li style="list-style-type:circle">connect smaller rank to larger rank</li></ul></li></ul><pre id="42bb748e-ce6b-4a1e-b474-412aeb120bf5" class="code code-wrap"><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

class DisjointSet
{
    vector&lt;int&gt; rank, parent;

public:
    DisjointSet(int n)
    {
        rank.resize(n + 1, 0);
        parent.resize(n + 1);
        for (int i = 0; i &lt; n + 1; i++)
            parent[i] = i;
    }

    int findUltimateParent(int node)
    {
        if (node == parent[node])
            return node;
        return parent[node] = findUltimateParent(parent[node]);
    }

    void unionByRank(int u, int v)
    {
        int ulp_u = findUltimateParent(u);
        int ulp_v = findUltimateParent(v);

        if (ulp_u == ulp_v)
            return;
        if (rank[ulp_u] &lt; rank[ulp_v])
        {
            parent[ulp_u] = ulp_v;
        }
        else if (rank[ulp_v] &lt; rank[ulp_u])
        {
            parent[ulp_v] = ulp_u;
        }
        else
        {
            parent[ulp_v] = ulp_u;
            rank[ulp_u]++;
        }
    }
};

int main()
{
    DisjointSet ds(7);
    ds.unionByRank(1, 2);
    ds.unionByRank(2, 3);
    ds.unionByRank(4, 5);
    ds.unionByRank(6, 7);
    ds.unionByRank(5, 6);
    if (ds.findUltimateParent(3) == ds.findUltimateParent(7))
    {
        cout &lt;&lt; &quot;Same&quot; &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; &quot;Not Same&quot; &lt;&lt; endl;
    }
    ds.unionByRank(3, 7);
    if (ds.findUltimateParent(3) == ds.findUltimateParent(7))
    {
        cout &lt;&lt; &quot;Same&quot; &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; &quot;Not Same&quot; &lt;&lt; endl;
    }
}</code></pre><ul id="ab276ca9-73dc-466d-9fdd-15f900dc885c" class="bulleted-list"><li style="list-style-type:disc">Number of provinces → we can use bfs and dfs also but dsu also we can use<ul id="f8101b62-44ff-4328-8252-486707a5bdc3" class="bulleted-list"><li style="list-style-type:circle">We can use ultimate parent wala logic</li></ul></li></ul><ul id="3fd8a840-3bb7-4661-a290-22c09a4b77bd" class="bulleted-list"><li style="list-style-type:disc">Number of operations to make network connected  → Answer is number of connected components - 1 and you check availability of duplicate edges by checking if parents are same</li></ul><h1 id="386ae5c8-e434-4fa5-b36b-6f01d59cc2b8" class="">Minimum Spanning Tree</h1><ul id="c3ee9b52-9a13-4b30-8e62-fd028b45eb88" class="bulleted-list"><li style="list-style-type:disc">A tree in which we have n nodes and n-1 edges and all nodes should be available</li></ul><h3 id="f8fabb84-510d-46ac-b719-0e1ec0e07698" class="">Prims (Uses BFS)</h3><ul id="9ab58f8a-8400-4680-b952-1ac0c94d826b" class="bulleted-list"><li style="list-style-type:disc">We use visited array and priority queue where we store weight, node and parent and start with 0,0,-1<ul id="379835c2-5601-4b38-a10c-4062091bf150" class="bulleted-list"><li style="list-style-type:circle">we mark it as visited but do not push to mst</li></ul><ul id="867752e2-b216-497e-9f3b-c5d853716399" class="bulleted-list"><li style="list-style-type:circle">next least weight wala we take push it to mst and mark node as visited</li></ul><ul id="0e5675aa-7e51-43b9-82ed-56e11e0c7db0" class="bulleted-list"><li style="list-style-type:circle">and we sorta do bfs only and if it’s unvisited mark it as visited</li></ul><figure id="95d564a3-6485-485f-96c7-f979de747023" class="image"><a href="Lab%20Sheets%20and%20Notes%207b554b951577449fa210013fdf50ecf5/Untitled%202.png"><img style="width:688px" src="Lab%20Sheets%20and%20Notes%207b554b951577449fa210013fdf50ecf5/Untitled%202.png"/></a></figure></li></ul><h3 id="e65d207e-1f62-42c1-874b-6d2700edb5b1" class="">Kruskal’s (Uses DSU)</h3><ul id="f908c5e5-4ca5-4c83-a560-6e210e2bd66d" class="bulleted-list"><li style="list-style-type:disc">We sort edges based on weight and iterate through each of them</li></ul><ul id="25f881c2-f173-4abf-b9d9-5107c599fbf5" class="bulleted-list"><li style="list-style-type:disc">We check if they belong to the same component or not and update the parts of the MST. Like if they belong to same component we ignore these</li></ul><ul id="58294a47-4fa0-42fa-bc05-d85fa5b63823" class="bulleted-list"><li style="list-style-type:disc">We do not take those which connect two nodes of the same component</li></ul><ul id="722b993c-a01e-4f40-9acf-435d222b7960" class="bulleted-list"><li style="list-style-type:disc">So like kruskals is sort of greedy approach</li></ul><h1 id="3e641b89-7272-4f74-bddb-9f73ecf890e0" class="">Fenwick Tree aka Binary Indexed Tree</h1><figure id="a7b69d5f-a792-4cc1-abec-fb3b00d66bb5" class="image"><a href="Lab%20Sheets%20and%20Notes%207b554b951577449fa210013fdf50ecf5/Untitled%203.png"><img style="width:1885px" src="Lab%20Sheets%20and%20Notes%207b554b951577449fa210013fdf50ecf5/Untitled%203.png"/></a></figure><ul id="82b7d2d1-0196-41a5-be00-5273e293993c" class="bulleted-list"><li style="list-style-type:disc">Let’s assume the function is the sum function</li></ul><ul id="d07db355-99de-46b4-a490-a390c1d78d46" class="bulleted-list"><li style="list-style-type:disc">Given array A of integers from 0 to n-1, fenwick tree is just an array T[0…n-1] where each of it’s elements is equal to sum of elements of A in the range [g(i), i]<figure id="29799927-fbc4-4524-8842-0ae6971b1ae3" class="image"><a href="Lab%20Sheets%20and%20Notes%207b554b951577449fa210013fdf50ecf5/Untitled%204.png"><img style="width:840px" src="Lab%20Sheets%20and%20Notes%207b554b951577449fa210013fdf50ecf5/Untitled%204.png"/></a></figure></li></ul><ul id="266308b4-1c38-4f5f-abf3-4acafa758bb2" class="bulleted-list"><li style="list-style-type:disc">g should satisfy 0 ≤ g ≤ i</li></ul><pre id="a0442790-48e7-4896-8611-793fae5bf180" class="code code-wrap"><code>int getSumOfRange(int r){
	// gets sum of range 0 to r both included
	int result = 0;
	while(r &gt;= 0){
		res += t[r];
		r = g(r) - 1;
	}
}

// If we notice, this function is basically recursively finding sum from g(r) to r -&gt; g(g(r)-1) to g(r)-1 and so on
// and we go till g(-1), -1 

void update(int index, int delta){
	for(int i=0; i&lt;n; i++){
		if(g(i) &lt;= index &amp;&amp; index &lt;= i){
			t[i] += delta;
		}
	}
}</code></pre><ul id="97d6caef-5006-4e74-b40e-01c2c0e156f4" class="bulleted-list"><li style="list-style-type:disc">We observe that if g(i) = 0 which will basically lead to a prefix sum array but then this would imply very hard updations</li></ul><ul id="3b077e44-b948-48d6-8d45-bf5fe4dafa79" class="bulleted-list"><li style="list-style-type:disc">We use g(i) → we replace all trailing 1 bits in the binary representation of i with 0 bits → g(i) = i &amp; (i + 1)</li></ul><ul id="a8d2555f-c293-45f3-9d75-b3a67b81321e" class="bulleted-list"><li style="list-style-type:disc">And during updating, we can use h function to see which all i(s) are available implying h(j) = j || j + 1</li></ul><pre id="3d04e952-669c-4f82-aafb-93787b33ad38" class="code"><code>class FenwickTree
{
    int n;
    vector&lt;int&gt; T;
    vector&lt;int&gt; arr;

public:
    FenwickTree(int n)
    {
        this-&gt;n = n;
        T.resize(n, 0);
    }

    FenwickTree(vector&lt;int&gt; &amp;arr) : FenwickTree(arr.size())
    {
        this-&gt;arr = arr;
        for (int i = 0; i &lt; n; i++)
        {
            T[i] += arr[i];
            int r = h(i);
            if (r &lt; n)
                T[r] += T[i];
        }
        // cout &lt;&lt; &quot;Initialized Fenwick Tree&quot; &lt;&lt; endl;
    }

    int g(int r)
    {
        return r &amp; (r + 1);
    }

    int h(int j)
    {
        return j | (j + 1);
    }

    int sum(int r)
    {
        int res = 0;
        for (int k = r; k &gt;= 0; k = g(k) - 1)
        {
            res += T[k];
        }
        return res;
    }

    int sum(int l, int r)
    {
        // cout &lt;&lt; &quot;Finding Sum: &quot; &lt;&lt; l &lt;&lt; &quot; to &quot; &lt;&lt; r &lt;&lt; endl;
        return sum(r) - sum(l - 1);
    }

    void update(int index, int newValue)
    {
        // cout &lt;&lt; &quot;Updating value at index: &quot; &lt;&lt; index &lt;&lt; &quot; to &quot; &lt;&lt; newValue &lt;&lt; endl;
        int delta = newValue - this-&gt;arr[index];
        this-&gt;arr[index] = newValue;
        for (int i = index; i &lt; n; i = h(i))
        {
            T[i] += delta;
        }
    }
};</code></pre><h1 id="761625ec-261a-4748-8d3d-5f7319761eba" class="">Segment Tree</h1><ul id="a1aee9f7-9cc2-438d-b224-89720e2a688a" class="bulleted-list"><li style="list-style-type:disc">Stores information about array intervals in a tree</li></ul><h1 id="ca95381b-b575-4cec-81a0-5a861d60d938" class="">Minimum Exclusion Number</h1><pre id="d42317d3-7a24-401a-88bf-29dac861c1f9" class="code code-wrap"><code>class Mex {
private:
    map&lt;int, int&gt; frequency;
    set&lt;int&gt; missing_numbers;
    vector&lt;int&gt; A;

public:
    Mex(vector&lt;int&gt; const&amp; A) : A(A) {
        for (int i = 0; i &lt;= A.size(); i++)
            missing_numbers.insert(i);

        for (int x : A) {
            ++frequency[x];
            missing_numbers.erase(x);
        }
    }

    int mex() {
        return *missing_numbers.begin();
    }

    void update(int idx, int new_value) {
        if (--frequency[A[idx]] == 0)
            missing_numbers.insert(A[idx]);
        A[idx] = new_value;
        ++frequency[new_value];
        missing_numbers.erase(new_value);
    }
};</code></pre><ul id="112af0d9-d156-4c82-a180-0fce81d4b407" class="bulleted-list"><li style="list-style-type:disc">So basically you remove all the numbers from set except the missing ones on initialization and then </li></ul><p id="b9de950b-44c0-43dd-9fdc-26a4179a3a47" class="">
</p></div></article></body></html>